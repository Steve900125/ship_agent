from typing import List, Tuple, Optional, Dict
from datetime import datetime
from pathlib import Path
import sqlite3

# Define the database path in the current directory
PATH = Path(__file__).resolve().parent
db_path = PATH / "conversations.db"

# Path to the SQL file for creating tables
sql_file_path = PATH / "create_tables.sql"

if not sql_file_path.exists():
    raise FileNotFoundError(f"SQL file not found: {sql_file_path}")

def initialize_database(db_path: Path, sql_file_path: Path):
    """
    Initializes the database by creating tables using the SQL script.

    Args:
        db_path (Path): Path to the SQLite database file.
        sql_file_path (Path): Path to the SQL script file for creating tables.

    Raises:
        sqlite3.DatabaseError: If an error occurs during database initialization.
    """
    with sqlite3.connect(db_path) as conn:
        cursor = conn.cursor()
        sql_script = sql_file_path.read_text()
        cursor.executescript(sql_script)  # Execute the SQL script.
        conn.commit()

def insert_conversation(
    db_path: Path, user_id: str, user_message: str, ai_message: str, timestamp: Optional[str] = None
):
    """
    Inserts a conversation record into the database. Automatically uses the current timestamp if not provided.

    Args:
        db_path (Path): Path to the SQLite database file.
        user_id (str): The unique identifier for the user.
        user_message (str): The message sent by the user.
        ai_message (str): The message generated by the AI.
        timestamp (Optional[str]): The timestamp for the record. If None, the current timestamp is used.

    Raises:
        sqlite3.DatabaseError: If an error occurs while inserting the record.
    """
    if timestamp is None:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    insert_sql = """
    INSERT INTO conversation_records (user_id, user_message, ai_message, timestamp)
    VALUES (?, ?, ?, ?);
    """
    with sqlite3.connect(db_path) as conn:
        cursor = conn.cursor()
        cursor.execute(insert_sql, (user_id, user_message, ai_message, timestamp))
        conn.commit()


def fetch_conversations(db_path: Path, user_id: str) -> List[Tuple[int, str, str, str]]:
    """
    Fetches all conversation records for a given user ID.

    Args:
        db_path (Path): Path to the SQLite database file.
        user_id (str): The unique identifier for the user whose conversations are to be retrieved.

    Returns:
        List[Tuple[int, str, str, str]]: A list of tuples, where each tuple contains the following:
            - id (int): The record ID.
            - user_message (str): The message sent by the user.
            - ai_message (str): The message generated by the AI.
            - timestamp (str): The timestamp of the record.

    Raises:
        sqlite3.DatabaseError: If an error occurs while fetching records.
    """
    select_sql = """
    SELECT id, user_message, ai_message, timestamp
    FROM conversation_records
    WHERE user_id = ?
    ORDER BY timestamp DESC;
    """
    with sqlite3.connect(db_path) as conn:
        cursor = conn.cursor()
        cursor.execute(select_sql, (user_id,))
        return cursor.fetchall()


# Initialize the database and create tables
initialize_database(db_path, sql_file_path)

# Test inserting and retrieving conversation records
if __name__ == "__main__":
    # Insert test records
    insert_conversation(db_path, "user_123", "Hello, AI!", "Hello, user!")
    # insert_conversation(db_path, "user_123", "How are you?", "I'm just a program, but I'm fine.", "2025-01-17 16:00:00")
    # insert_conversation(db_path, "user_123", "What's the weather?", "I don't know, check a weather app.")

    # Fetch and display all conversations for user_123
    print("All conversations for user_123:")
    all_conversations = fetch_conversations(db_path, "user_123")
    for convo in all_conversations:
        print(convo)
